[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = -1;

alias userSP R1;
userSP = SP;

// switch to kernel and backup
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 13] = SP;
SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 11]*512 -1 ;

backup;
multipush(EIP);

if(EC == 1)then
    print "Illegal Instruction";
    // call exit prcs
    multipush(R1);
    R1 = 3;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MOD_1;
    multipop(R1);
    // call scheduler 
    call MOD_5;
endif;

if(EC == 2)then
    print "Illegal mem accs";
    // call exit prcs
    multipush(R1);
    R1 = 3;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MOD_1;
    multipop(R1);
    // call scheduler 
    call MOD_5;
endif;

if(EC == 3)then
    print "Arthematic error";
    // call exit prcs
    multipush(R1);
    R1 = 3;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MOD_1;
    multipop(R1);
    // call scheduler 
    call MOD_5;
endif;

// Stack full
if (userSP == (PTLR*512-1) )then
    print "Stack full";
    // call exit prcs
    multipush(R1);
    R1 = 3;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MOD_1;
    multipop(R1);
    // call scheduler 
    call MOD_5;
endif;


// if it is page fault 
if (EC == 0 )then 
    // code page missing
    if(EPN==4 || EPN==5 || EPN==6 || EPN==7) then 
		multipush(R1);
			R1=5;
			R2=[SYSTEM_STATUS_TABLE+1];
			R3=[DISK_MAP_TABLE + 10*[SYSTEM_STATUS_TABLE+1]+EPN];
			call MOD_2;
            breakpoint;
			[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN]=R0;
			[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN + 1]="1100";
		multipop(R1);
	endif;
    // heap page missing 
    if(EPN==2 || EPN==3) then 
		multipush(R1);
		R1=1;
		call MOD_2; 
		[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN]=R0;
		[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN + 1]="1110";
		multipop(R1);
	endif;

endif;
multipop(EIP);

breakpoint;

restore;
// reset mode to 0
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = 0;

SP=userSP;
SP=SP+1;
// push EIP to stack 
[[PTBR+2*(SP/512)]*512+(SP%512)]=EIP;
ireturn;